<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>古钱占卜</title>
    <style>
        body { margin: 0; background: #111; overflow: hidden; }
        #flipButton {
            position: absolute;
            top: 20px; left: 20px;
            padding: 10px 20px;
            background: #FFD700;
            border: none;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <button id="flipButton">翻转占卜</button>

    <!-- Three.js & GLTFLoader from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        let scene, camera, renderer, coin;

        // 初始化场景
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1, 3);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 灯光
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        // 加载 GLB 模型
        const loader = new THREE.GLTFLoader();
        loader.load('./chinese_coin.glb', function (gltf) {
            coin = gltf.scene;
            coin.scale.set(1, 1, 1);
            scene.add(coin);
        }, undefined, function (error) {
            console.error('加载模型失败:', error);
        });

        // 翻转按钮
        document.getElementById('flipButton').addEventListener('click', () => {
            if (!coin) return;
            let randomSide = Math.random() > 0.5 ? 0 : Math.PI; // 0 正面 / π 背面
            let start = coin.rotation.y;
            let end = start + (Math.PI * 10) + randomSide; // 多转几圈再落下
            let duration = 1500; // 动画时间
            let startTime = performance.now();

            function animateFlip(time) {
                let progress = Math.min((time - startTime) / duration, 1);
                coin.rotation.y = start + (end - start) * easeOutCubic(progress);
                if (progress < 1) {
                    requestAnimationFrame(animateFlip);
                }
            }
            requestAnimationFrame(animateFlip);
        });

        // 缓动函数
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }

        // 渲染循环
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // 自适应窗口大小
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
